<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://kokohuang.github.io/</id><title>kokohuang's blog</title><subtitle>kokohuang's blog.</subtitle> <updated>2021-04-06T11:31:26+08:00</updated> <author> <name>kokohuang</name> <uri>https://kokohuang.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://kokohuang.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://kokohuang.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 kokohuang </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Swift算法&amp;数据结构学习笔记 - 排序</title><link href="https://kokohuang.github.io/posts/swift-algorithm-sort/" rel="alternate" type="text/html" title="Swift算法&amp;数据结构学习笔记 - 排序" /><published>2021-04-01T12:00:00+08:00</published> <updated>2021-04-02T16:52:55+08:00</updated> <id>https://kokohuang.github.io/posts/swift-algorithm-sort/</id> <content src="https://kokohuang.github.io/posts/swift-algorithm-sort/" /> <author> <name>kokohuang</name> </author> <category term="代码人生" /> <category term="算法&amp;数据结构" /> <summary> Swift </summary> </entry> <entry><title>Swift算法&amp;数据结构学习笔记 - 字符串搜索</title><link href="https://kokohuang.github.io/posts/swift-algorithm-string-search/" rel="alternate" type="text/html" title="Swift算法&amp;数据结构学习笔记 - 字符串搜索" /><published>2021-03-31T12:00:00+08:00</published> <updated>2021-04-02T16:52:55+08:00</updated> <id>https://kokohuang.github.io/posts/swift-algorithm-string-search/</id> <content src="https://kokohuang.github.io/posts/swift-algorithm-string-search/" /> <author> <name>kokohuang</name> </author> <category term="代码人生" /> <category term="算法&amp;数据结构" /> <summary> Swift </summary> </entry> <entry><title>Swift算法&amp;数据结构学习笔记 - 搜索</title><link href="https://kokohuang.github.io/posts/swift-algorithm-search/" rel="alternate" type="text/html" title="Swift算法&amp;数据结构学习笔记 - 搜索" /><published>2021-03-30T17:08:19+08:00</published> <updated>2021-04-02T16:52:55+08:00</updated> <id>https://kokohuang.github.io/posts/swift-algorithm-search/</id> <content src="https://kokohuang.github.io/posts/swift-algorithm-search/" /> <author> <name>kokohuang</name> </author> <category term="代码人生" /> <category term="算法&amp;数据结构" /> <summary> Swift </summary> </entry> <entry><title>Swift算法&amp;数据结构学习笔记 - 开篇</title><link href="https://kokohuang.github.io/posts/swift-algorithm-start/" rel="alternate" type="text/html" title="Swift算法&amp;数据结构学习笔记 - 开篇" /><published>2021-03-29T12:00:00+08:00</published> <updated>2021-04-02T16:52:55+08:00</updated> <id>https://kokohuang.github.io/posts/swift-algorithm-start/</id> <content src="https://kokohuang.github.io/posts/swift-algorithm-start/" /> <author> <name>kokohuang</name> </author> <category term="代码人生" /> <category term="算法&amp;数据结构" /> <summary> Hello, Swift! 该系列文章是记录自己在学习开源项目Swift Algorithm Club 的一些笔记及心得。 1. 栈 栈类似于数组，但相对于数组来说，栈有很多限制性。栈只允许我们从栈顶压入(push)元素；从栈弹出(pop)元素；在不弹出的情况下取得(peek)栈顶元素。 栈可以保证元素存入和取出的顺序是后进先出(Last-In First-Out, LIFO)的。栈中弹出的元素总是你最后放进去的那个。 队列则是先进先出(First-In, First-Out, FIFO)的结构。 需要注意的是，压栈操作是将新元素压入数组的尾部，而不是头部。在数组的头部插入元素是一个很耗时的操作，它的时间复杂度为O(n)，因为需要将现有元素往后移位为新元素腾出空间。而在尾部插入元素的时间复杂度为O(1)；无论数组有多少元素，这个操作所消耗的时间都是一个常量。 栈(Sta... </summary> </entry> <entry><title>Swift设计模式概览</title><link href="https://kokohuang.github.io/posts/swift-design-patterns/" rel="alternate" type="text/html" title="Swift设计模式概览" /><published>2020-05-01T12:00:00+08:00</published> <updated>2020-05-01T12:00:00+08:00</updated> <id>https://kokohuang.github.io/posts/swift-design-patterns/</id> <content src="https://kokohuang.github.io/posts/swift-design-patterns/" /> <author> <name>kokohuang</name> </author> <category term="代码人生" /> <category term="设计模式" /> <summary> 创建型模式 工厂方法模式：在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。 抽象工厂模式：让你能创建一系列相关的对象，而无需指定其具体类。 生成器模式：使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。 原型模式：使你能够复制已有对象，而又无需使代码依赖它们所属的类。 单例模式：让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。 结构型模式 适配器模式：使接口不兼容的对象能够相互合作。 桥接模式：可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。 组合模式：可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它... </summary> </entry> </feed>
