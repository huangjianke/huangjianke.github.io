I"
<meta name="referrer" content="no-referrer" />

<blockquote>
  <p>启逻辑之高妙，因想象而自由</p>
</blockquote>

<p><strong>层叠拼图Plus</strong>是一款需要空间想象力和逻辑推理能力完美结合的微信小游戏，偶消奇不消，在简单的游戏规则下却有着无数种可能性，需要你充分发挥想象力去探索，看似简单却具有极大的挑战性和趣味性，这就是其魅力所在！</p>

<!--more-->

<p>游戏界面预览：</p>

<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0494a8829d90c?w=500&amp;h=541&amp;f=png&amp;s=94442" alt="preview" /></p>

<blockquote>
  <p>Talk is cheap. Show me the code</p>
</blockquote>

<p><strong>层叠拼图Plus</strong>微信小游戏采用<code class="language-plaintext highlighter-rouge">js</code>+<code class="language-plaintext highlighter-rouge">canvas</code>实现，没有使用任何游戏引擎，对于初学者来说，也比较容易入门。接下来，我将通过以下几个点循序渐进的讲解<strong>层叠拼图Plus</strong>微信小游戏的实现。</p>

<ul>
  <li><strong>如何解决Canvas绘图模糊？</strong></li>
  <li><strong>如何绘制任意多边形图形？</strong></li>
  <li><strong>1 + 1 = 0，「偶消奇不消」的效果如何实现？</strong></li>
  <li><strong>如何判断一个点是否在任意多边形内部 ？</strong></li>
  <li><strong>如何判断游戏结果是否正确？</strong></li>
  <li><strong>排行榜的展示</strong></li>
  <li><strong>游戏性能优化</strong></li>
</ul>

<h2 id="如何解决canvas绘图模糊">如何解决Canvas绘图模糊？</h2>

<blockquote>
  <p>canvas 绘图时，会从两个物理像素的中间位置开始绘制并向两边扩散 0.5 个物理像素。当设备像素比为 1 时，一个 1px 的线条实际上占据了两个物理像素（每个像素实际上只占一半），由于不存在 0.5 个像素，所以这两个像素本来不应该被绘制的部分也被绘制了，于是 1 物理像素的线条变成了 2 物理像素，视觉上就造成了模糊</p>
</blockquote>

<p>绘图模糊的原因知道了，在微信小游戏里面又该如何解决呢？</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td> --><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">ratio</span> <span class="o">=</span> <span class="nx">wx</span><span class="p">.</span><span class="nx">getSystemInfoSync</span><span class="p">().</span><span class="nx">pixelRatio</span>
<span class="kd">let</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">2d</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">screenWidth</span> <span class="o">*</span> <span class="nx">ratio</span>
<span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="nx">screenHeight</span> <span class="o">*</span> <span class="nx">ratio</span>

<span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nx">font</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="mi">18</span> <span class="o">*</span> <span class="nx">ratio</span><span class="p">}</span><span class="s2">px Arial`</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nx">fillText</span><span class="p">(</span><span class="dl">'</span><span class="s1">我是清晰的文字</span><span class="dl">'</span><span class="p">,</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">ratio</span><span class="p">,</span> <span class="nx">y</span> <span class="o">*</span> <span class="nx">ratio</span><span class="p">)</span>

<span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">red</span><span class="dl">'</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nx">fillRect</span><span class="p">(</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">ratio</span><span class="p">,</span> <span class="nx">y</span> <span class="o">*</span> <span class="nx">ratio</span><span class="p">,</span> <span class="nx">width</span> <span class="o">*</span> <span class="nx">ratio</span><span class="p">,</span> <span class="nx">height</span> <span class="o">*</span> <span class="nx">ratio</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>可以看到，我们先通过 <code class="language-plaintext highlighter-rouge">wx.getSystemInfoSync().pixelRatio</code> 获取设备的像素比<code class="language-plaintext highlighter-rouge">ratio</code>，然后将在屏 <code class="language-plaintext highlighter-rouge">Canvas</code> 的宽度和高度按照所获取的像素比<code class="language-plaintext highlighter-rouge">ratio</code>进行放大，在绘制文字、图片的时候，坐标点 <code class="language-plaintext highlighter-rouge">x</code>、<code class="language-plaintext highlighter-rouge">y</code> 和所要绘制图形的 <code class="language-plaintext highlighter-rouge">width</code>、<code class="language-plaintext highlighter-rouge">height</code>均需要按照像素比 <code class="language-plaintext highlighter-rouge">ratio</code> 进行缩放，这样我们就可以清晰的在高清屏中绘制想要的文字、图片。</p>

<p>可参考微信官方 <a href="https://developers.weixin.qq.com/community/develop/doc/00040c9903023848e0d7bd6205a401?highLine=canvas%2520%25E6%25A8%25A1%25E7%25B3%258A">缩放策略调整</a></p>

<p><strong><em>另外，需要注意的是，这里的 <code class="language-plaintext highlighter-rouge">canvas</code> 是由 <a href="https://developers.weixin.qq.com/minigame/dev/guide/best-practice/adapter.html">weapp-adapter</a> 预先调用 <code class="language-plaintext highlighter-rouge">wx.createCanvas()</code> 创建一个上屏 <code class="language-plaintext highlighter-rouge">Canvas</code>，并暴露为一个全局变量 <code class="language-plaintext highlighter-rouge">canvas</code>。</em></strong></p>

<h2 id="如何绘制任意多边形图形">如何绘制任意多边形图形？</h2>

<blockquote>
  <p>任意一个多边形图形，是由多个平面坐标点所组成的图形区域。</p>
</blockquote>

<p>在游戏画布内，我们以左上角为坐标原点 <code class="language-plaintext highlighter-rouge">{x: 0, y: 0}</code> ，一个多边形包含多个单位长度的平面坐标点，如：<code class="language-plaintext highlighter-rouge">[{ x: 1, y: 3 }, { x: 5, y: 3 }, { x: 3, y: 5 }]</code> 表示为一个三角形的区域，需要注意的是，<code class="language-plaintext highlighter-rouge">x</code>、<code class="language-plaintext highlighter-rouge">y</code> 并不是真实的平面坐标值，而是通过屏幕宽度计算出来的单位长度，在画布内的真实坐标值则为 <code class="language-plaintext highlighter-rouge">{x: x * itemWidth, y: y * itemWidth}</code> 。</p>

<p>绘制多边形代码实现如下：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td> --><td class="rouge-code"><pre><span class="cm">/**
 * 绘制多边形
 */</span>
<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">Block</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="nx">init</span><span class="p">(</span><span class="nx">points</span><span class="p">,</span> <span class="nx">itemWidth</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">itemWidth</span> <span class="o">=</span> <span class="nx">itemWidth</span> <span class="c1">// 单位长度</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">ctx</span> <span class="o">=</span> <span class="nx">ctx</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">points</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">point</span> <span class="o">=</span> <span class="nx">points</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">points</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
                <span class="na">x</span><span class="p">:</span> <span class="nx">point</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">itemWidth</span><span class="p">,</span>
                <span class="na">y</span><span class="p">:</span> <span class="nx">point</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">itemWidth</span>
            <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">draw</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">globalCompositeOperation</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">xor</span><span class="dl">'</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">beginPath</span><span class="p">()</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">moveTo</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">points</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">x</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">points</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">y</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">points</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">point</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">points</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">lineTo</span><span class="p">(</span><span class="nx">point</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">point</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">closePath</span><span class="p">()</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">fill</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>使用：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> --><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">points</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">5</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">9</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">9</span> <span class="p">}],</span>
    <span class="p">[{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">8</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">12</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">12</span> <span class="p">}],</span>
    <span class="p">[{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">4</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">4</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">8</span> <span class="p">}]</span>
<span class="p">]</span>
<span class="nx">points</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">sub_points</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">block</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Block</span><span class="p">()</span>
    <span class="nx">block</span><span class="p">.</span><span class="nx">init</span><span class="p">(</span><span class="nx">sub_points</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">itemWidth</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="nx">block</span><span class="p">.</span><span class="nx">draw</span><span class="p">()</span>
<span class="p">})</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>效果如下图：</p>

<p><img src="https://user-gold-cdn.xitu.io/2019/8/26/16ccb963282cbf04?w=300&amp;h=301&amp;f=png&amp;s=53047" alt="block" /></p>

<p><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D</code>其他使用方法可参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D">CanvasRenderingContext2D API 列表</a></p>

<h2 id="1--1--0偶消奇不消的效果如何实现">1 + 1 = 0，「偶消奇不消」的效果如何实现？</h2>

<blockquote>
  <p>1 + 1 = 0，是<strong>层叠拼图Plus</strong>小游戏玩法的精髓所在。</p>
</blockquote>

<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca96beb9a40d9f?w=300&amp;h=306&amp;f=png&amp;s=36811" alt="xor" /></p>

<p>有经验的同学，也许一眼就发现了，<code class="language-plaintext highlighter-rouge">1 + 1 = 0</code> 刚好符合通过 <code class="language-plaintext highlighter-rouge">异或运算</code> 得出的结果。当然，细心的同学也可能已经发现，在 <code class="language-plaintext highlighter-rouge">如何绘制任意多边形图形</code> 这一章节内，有一句特殊的代码：<code class="language-plaintext highlighter-rouge">this.ctx.globalCompositeOperation = 'xor'</code>，也正是通过设置 <code class="language-plaintext highlighter-rouge">CanvasContext</code> 的 <code class="language-plaintext highlighter-rouge">globalCompositeOperation</code> 属性值为 <code class="language-plaintext highlighter-rouge">xor</code> 便实现了「偶消奇不消」的神奇效果。</p>

<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca94dcda5b68f8?w=1526&amp;h=522&amp;f=png&amp;s=115558" alt="globalCompositeOperation" /></p>

<p><code class="language-plaintext highlighter-rouge">globalCompositeOperation</code> 是指 <code class="language-plaintext highlighter-rouge">在绘制新形状时应用的合成操作的类型</code>，其他效果可参考：<a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation">globalCompositeOperation 示例</a></p>

<h2 id="如何判断一个点是否在任意多边形内部">如何判断一个点是否在任意多边形内部？</h2>

<blockquote>
  <p>当回转数为 0 时，点在闭合曲线外部。</p>
</blockquote>

<p>讲到这里，我们已经知道如何在<code class="language-plaintext highlighter-rouge">Canvas</code>画布内绘制出偶消奇不消效果的层叠图形了，接下来我们来看下玩家如何移动选中的图形。我们发现绘制出的图形对象并没有提供点击事件绑定之类的操作，那又如何判断玩家选中了哪个图形呢？这里我们就需要去实现如何判断玩家触摸事件的<code class="language-plaintext highlighter-rouge">x</code>，<code class="language-plaintext highlighter-rouge">y</code>坐标在哪个多边形图形内部区域，从而判断出玩家选中的是哪一个多边形图形。</p>

<p>判断一个点是否在任意多边形内部有多种方法，比如：</p>

<ul>
  <li>射线法</li>
  <li>面积判别法</li>
  <li>叉乘判别法</li>
  <li>回转数法</li>
  <li>…</li>
</ul>

<p>在<strong>层叠拼图Plus</strong>小游戏内，采用的是 <code class="language-plaintext highlighter-rouge">回转数</code> 法来判断玩家触摸点是否在多边形内部。<code class="language-plaintext highlighter-rouge">回转数</code> 是拓扑学中的一个基本概念，具有很重要的性质和用途。当然，展开讨论 <code class="language-plaintext highlighter-rouge">回转数</code> 的概念并不在该文的讨论范围内，我们仅需了解一个概念：<strong>当回转数为 0 时，点在闭合曲线外部。</strong></p>

<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca95f23b785c58?w=300&amp;h=244&amp;f=gif&amp;s=252242" alt="round" /></p>

<p>上面面这张图动态演示了回转数的概念：图中红色曲线关于点（人所在位置）的回转数为 <code class="language-plaintext highlighter-rouge">2</code>。</p>

<p>对于给定的点和多边形，回转数应该怎么计算呢？</p>

<ul>
  <li>用线段分别连接点和多边形的全部顶点</li>
</ul>

<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca96251c22a09b?w=500&amp;h=360&amp;f=png&amp;s=27778" alt="all" /></p>

<ul>
  <li>计算所有点与相邻顶点连线的夹角</li>
</ul>

<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca9627a8a9c710?w=500&amp;h=360&amp;f=png&amp;s=33046" alt="line" /></p>

<ul>
  <li>计算所有夹角和。注意每个夹角都是有方向的，所以有可能是负值</li>
</ul>

<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca962d5d1f2d07?w=500&amp;h=360&amp;f=png&amp;s=35608" alt="sub" /></p>

<p>最后根据角度累加值计算回转数。360°（2π）相当于一次回转。</p>

<p>在使用 <code class="language-plaintext highlighter-rouge">JavaScript</code> 实现时，需要注意以下问题：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">JavaScript</code> 的数只有 <code class="language-plaintext highlighter-rouge">64</code> 位双精度浮点这一种。对于三角函数产生的无理数，浮点数计算不可避免会造成一些误差，因此在最后计算回转数需要做取整操作。</li>
  <li>通常情况下，平面直角坐标系内一个角的取值范围是 -π 到 π 这个区间，这也是 <code class="language-plaintext highlighter-rouge">JavaScript</code> 三角函数 <code class="language-plaintext highlighter-rouge">Math.atan2()</code> 返回值的范围。但 <code class="language-plaintext highlighter-rouge">JavaScript</code> 并不能直接计算任意两条线的夹角，我们只能先计算两条线与 <code class="language-plaintext highlighter-rouge">x</code> 正轴夹角，再取两者差值。这个差值的结果就有可能超出 <code class="language-plaintext highlighter-rouge">-π</code> 到 <code class="language-plaintext highlighter-rouge">π</code> 这个区间，因此我们还需要处理差值超出取值区间的情况。</li>
</ul>

<p>代码实现：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td> --><td class="rouge-code"><pre><span class="cm">/**
 * 判断点是否在多边形内/边上
 */</span>
<span class="nx">isPointInPolygon</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">poly</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">px</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span>
        <span class="nx">py</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span>
        <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">poly</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">sx</span> <span class="o">=</span> <span class="nx">poly</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">x</span><span class="p">,</span>
            <span class="nx">sy</span> <span class="o">=</span> <span class="nx">poly</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">y</span><span class="p">,</span>
            <span class="nx">tx</span> <span class="o">=</span> <span class="nx">poly</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">x</span><span class="p">,</span>
            <span class="nx">ty</span> <span class="o">=</span> <span class="nx">poly</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">y</span>

        <span class="c1">// 点与多边形顶点重合或在多边形的边上</span>
        <span class="k">if</span> <span class="p">((</span><span class="nx">sx</span> <span class="o">-</span> <span class="nx">px</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">px</span> <span class="o">-</span> <span class="nx">tx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="nx">sy</span> <span class="o">-</span> <span class="nx">py</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">py</span> <span class="o">-</span> <span class="nx">ty</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="nx">px</span> <span class="o">-</span> <span class="nx">sx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">ty</span> <span class="o">-</span> <span class="nx">sy</span><span class="p">)</span> <span class="o">===</span> <span class="p">(</span><span class="nx">py</span> <span class="o">-</span> <span class="nx">sy</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">-</span> <span class="nx">sx</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>

        <span class="c1">// 点与相邻顶点连线的夹角</span>
        <span class="kd">let</span> <span class="nx">angle</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">atan2</span><span class="p">(</span><span class="nx">sy</span> <span class="o">-</span> <span class="nx">py</span><span class="p">,</span> <span class="nx">sx</span> <span class="o">-</span> <span class="nx">px</span><span class="p">)</span> <span class="o">-</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">atan2</span><span class="p">(</span><span class="nx">ty</span> <span class="o">-</span> <span class="nx">py</span><span class="p">,</span> <span class="nx">tx</span> <span class="o">-</span> <span class="nx">px</span><span class="p">)</span>

        <span class="c1">// 确保夹角不超出取值范围（-π 到 π）</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">angle</span> <span class="o">&gt;=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">angle</span> <span class="o">=</span> <span class="nx">angle</span> <span class="o">-</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">angle</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">angle</span> <span class="o">=</span> <span class="nx">angle</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="p">}</span>
        <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">angle</span>
    <span class="p">}</span>

    <span class="c1">// 计算回转数并判断点和多边形的几何关系</span>
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="nx">sum</span> <span class="o">/</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="kc">false</span> <span class="p">:</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><em>注：该章节内容图片均来自网络，如有侵权，请告知删除。另外有兴趣的同学可以使用其他方法来实现判断一个点是否在任意多边形内部。</em></p>

<h2 id="如何判断游戏结果是否正确">如何判断游戏结果是否正确？</h2>

<blockquote>
  <p>探索的过程固然精彩，而结果却更令我们期待</p>
</blockquote>

<p>通过前面的介绍我们可以知道，判断游戏结果是否正确其实就是比对玩家组合图形的 <code class="language-plaintext highlighter-rouge">xor</code> 结果与目标图形的 <code class="language-plaintext highlighter-rouge">xor</code> 结果。那么如何求多个多边形 <code class="language-plaintext highlighter-rouge">xor</code> 的结果呢？ <a href="https://github.com/mfogel/polygon-clipping">polygon-clipping</a> 正是为此而生的。它不仅支持 <code class="language-plaintext highlighter-rouge">xor</code> 操作，还有其他的比如：<code class="language-plaintext highlighter-rouge">union</code>, <code class="language-plaintext highlighter-rouge">intersection</code>, <code class="language-plaintext highlighter-rouge">difference</code> 等操作。
在<strong>层叠拼图Plus</strong>游戏内通过 <a href="https://github.com/mfogel/polygon-clipping">polygon-clipping</a> 又是怎样实现游戏结果判断的呢？</p>

<ul>
  <li>目标图形</li>
</ul>

<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca99ee27b06341?w=300&amp;h=288&amp;f=png&amp;s=34253" alt="target" /></p>

<p>多边形平面坐标点集合：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre><span class="nx">points</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">6</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">6</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">10</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">10</span> <span class="p">}],</span>
    <span class="p">[{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">6</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">8</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">10</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">8</span> <span class="p">}]</span>
<span class="p">]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td> --><td class="rouge-code"><pre><span class="cm">/**
 * 获取 多个多边形 xor 结果
 */</span>
<span class="kd">const</span> <span class="nx">polygonClipping</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">polygon-clipping</span><span class="dl">'</span><span class="p">)</span>

<span class="nx">polygonXor</span><span class="p">(</span><span class="nx">points</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">poly</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="nx">points</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">sub_points</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">temp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="nx">sub_points</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">point</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">temp</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">point</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">point</span><span class="p">.</span><span class="nx">y</span><span class="p">])</span>
        <span class="p">})</span>
        <span class="nx">poly</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">temp</span><span class="p">])</span>
    <span class="p">})</span>

    <span class="kd">let</span> <span class="nx">results</span> <span class="o">=</span> <span class="nx">polygonClipping</span><span class="p">.</span><span class="nx">xor</span><span class="p">(...</span><span class="nx">poly</span><span class="p">)</span>

    <span class="c1">// 找出左上角的点</span>
    <span class="kd">let</span> <span class="nx">min_x</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="nx">min_y</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="nx">results</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">sub_results</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">sub_results</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">temps</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">temps</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">point</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">min_x</span><span class="p">)</span> <span class="nx">min_x</span> <span class="o">=</span> <span class="nx">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">min_y</span><span class="p">)</span> <span class="nx">min_y</span> <span class="o">=</span> <span class="nx">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">})</span>
        <span class="p">})</span>
    <span class="p">})</span>

    <span class="c1">// 以左上角为参考点 多边形平移至 原点 {x: 0, y: 0}</span>
    <span class="nx">results</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">sub_results</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">sub_results</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">temps</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">temps</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">point</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="nx">min_x</span>
                <span class="nx">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="nx">min_y</span>
            <span class="p">})</span>
        <span class="p">})</span>
    <span class="p">})</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">xor</code>结果：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td> --><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">polygonXor</span><span class="p">(</span><span class="nx">points</span><span class="p">)</span>
<span class="nx">result</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]],</span>
    <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]],</span>
    <span class="p">[[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]],</span>
    <span class="p">[[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]]</span>
<span class="p">]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>同理计算出玩家操作图形的<code class="language-plaintext highlighter-rouge">xor</code>结果进行比对即可得出答案正确与否。</p>

<p><strong><em>需要注意的是，获取玩家的 <code class="language-plaintext highlighter-rouge">xor</code> 结果并不能直接拿来与目标图形<code class="language-plaintext highlighter-rouge">xor</code> 结果进行比较，我们需要将<code class="language-plaintext highlighter-rouge">xor</code> 的结果以左上角为参考点将图形平移至原点内，然后再进行比较，如果结果一致，则代表玩家答案正确。</em></strong></p>

<h2 id="排行榜的展示">排行榜的展示</h2>

<blockquote>
  <p>有人的地方就有江湖，有江湖的地方就有排行</p>
</blockquote>

<p>在看本章节内容之前，建议先浏览一遍排行榜相关的官方文档：<a href="https://developers.weixin.qq.com/minigame/dev/guide/open-ability/ranklist.html">好友排行榜</a>、<a href="https://developers.weixin.qq.com/minigame/dev/guide/open-ability/open-data.html">关系链数据</a>，以便对相关内容有个大概的了解。</p>

<ul>
  <li>开放数据域</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">开放数据域</code>是一个封闭、独立的 <code class="language-plaintext highlighter-rouge">JavaScript</code> 作用域。要让代码运行在开放数据域，需要在 <code class="language-plaintext highlighter-rouge">game.json</code> 中添加配置项 <code class="language-plaintext highlighter-rouge">openDataContext</code> 指定开放数据域的代码目录。添加该配置项表示小游戏启用了开放数据域，这将会导致一些限制。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre><span class="c1">// game.json</span>
<span class="p">{</span>
  <span class="dl">"</span><span class="s2">openDataContext</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">src/myOpenDataContext</span><span class="dl">"</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>
    <p>在游戏内使用 <code class="language-plaintext highlighter-rouge">wx.setUserCloudStorage(obj)</code> 对玩家游戏数据进行托管。</p>
  </li>
  <li>
    <p>在开放数据域内使用 <code class="language-plaintext highlighter-rouge">wx.getFriendCloudStorage(obj)</code>拉取当前用户所有同玩好友的托管数据</p>
  </li>
  <li>
    <p>展示关系链数据</p>
  </li>
</ul>

<p>如果想要展示通过关系链 <code class="language-plaintext highlighter-rouge">API</code> 获取到的用户数据，如绘制排行榜等业务场景，需要将排行榜绘制到 <code class="language-plaintext highlighter-rouge">sharedCanvas</code> 上，再在主域将 <code class="language-plaintext highlighter-rouge">sharedCanvas</code> 渲染上屏。</p>

<p><img src="https://user-gold-cdn.xitu.io/2019/8/20/16cad11323cccf61?w=620&amp;h=460&amp;f=png&amp;s=16321" alt="rank" /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td> --><td class="rouge-code"><pre><span class="c1">// src/myOpenDataContext/index.js</span>
<span class="kd">let</span> <span class="nx">sharedCanvas</span> <span class="o">=</span> <span class="nx">wx</span><span class="p">.</span><span class="nx">getSharedCanvas</span><span class="p">()</span>

<span class="kd">function</span> <span class="nx">drawRankList</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">item</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="nx">wx</span><span class="p">.</span><span class="nx">getFriendCloudStorage</span><span class="p">({</span>
  <span class="na">success</span><span class="p">:</span> <span class="nx">res</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">res</span><span class="p">.</span><span class="nx">data</span>
    <span class="nx">drawRankList</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">})</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">sharedCanvas</code> 是主域和开放数据域都可以访问的一个离屏画布。在开放数据域调用 <code class="language-plaintext highlighter-rouge">wx.getSharedCanvas()</code> 将返回 <code class="language-plaintext highlighter-rouge">sharedCanvas</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td> --><td class="rouge-code"><pre><span class="c1">// src/myOpenDataContext/index.js</span>
<span class="kd">let</span> <span class="nx">sharedCanvas</span> <span class="o">=</span> <span class="nx">wx</span><span class="p">.</span><span class="nx">getSharedCanvas</span><span class="p">()</span>
<span class="kd">let</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">sharedCanvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">2d</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">context</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">red</span><span class="dl">'</span>
<span class="nx">context</span><span class="p">.</span><span class="nx">fillRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>在主域中可以通过开放数据域实例访问 <code class="language-plaintext highlighter-rouge">sharedCanvas</code>，通过 <code class="language-plaintext highlighter-rouge">drawImage()</code> 方法可以将 <code class="language-plaintext highlighter-rouge">sharedCanvas</code> 绘制到上屏画布。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td> --><td class="rouge-code"><pre><span class="c1">// game.js</span>
<span class="kd">let</span> <span class="nx">openDataContext</span> <span class="o">=</span> <span class="nx">wx</span><span class="p">.</span><span class="nx">getOpenDataContext</span><span class="p">()</span>
<span class="kd">let</span> <span class="nx">sharedCanvas</span> <span class="o">=</span> <span class="nx">openDataContext</span><span class="p">.</span><span class="nx">canvas</span>

<span class="kd">let</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nx">wx</span><span class="p">.</span><span class="nx">createCanvas</span><span class="p">()</span>
<span class="kd">let</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">2d</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">context</span><span class="p">.</span><span class="nx">drawImage</span><span class="p">(</span><span class="nx">sharedCanvas</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">sharedCanvas</code> 本质上也是一个离屏 <code class="language-plaintext highlighter-rouge">Canvas</code>，而重设 <code class="language-plaintext highlighter-rouge">Canvas</code> 的宽高会清空 <code class="language-plaintext highlighter-rouge">Canvas</code> 上的内容。所以要通知开放数据域去重绘 <code class="language-plaintext highlighter-rouge">sharedCanvas</code>。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td> --><td class="rouge-code"><pre><span class="c1">// game.js</span>
<span class="nx">openDataContext</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">({</span>
  <span class="na">command</span><span class="p">:</span> <span class="dl">'</span><span class="s1">render</span><span class="dl">'</span>
<span class="p">})</span>

<span class="c1">// src/myOpenDataContext/index.js</span>
<span class="nx">openDataContext</span><span class="p">.</span><span class="nx">onMessage</span><span class="p">(</span><span class="nx">data</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">command</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">render</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 重绘 sharedCanvas</span>
  <span class="p">}</span>
<span class="p">})</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong><em>需要注意的是：<code class="language-plaintext highlighter-rouge">sharedCanvas</code> 的宽高只能在主域设置，不能在开放数据域中设置。</em></strong></p>

<h2 id="游戏性能优化">游戏性能优化</h2>

<blockquote>
  <p>性能优化，简而言之，就是在不影响系统运行正确性的前提下，使之运行地更快，完成特定功能所需的时间更短。</p>
</blockquote>

<p>一款能让人心情愉悦的游戏，性能问题必然不能成为绊脚石。那么可以从哪些方面对游戏进行性能优化呢？</p>

<h3 id="离屏-canvas">离屏 <code class="language-plaintext highlighter-rouge">Canvas</code></h3>

<p>在<strong>层叠拼图Plus</strong>小游戏内，针对需要大量使用且绘图繁复的静态场景，都是使用离屏 <code class="language-plaintext highlighter-rouge">Canvas</code>进行绘制的，如首页网格背景、关卡列表、排名列表等。在微信内 <code class="language-plaintext highlighter-rouge">wx.createCanvas()</code> 首次调用创建的是显示在屏幕上的画布，之后调用创建的都是离屏画布。初始化时将静态场景绘制完备，需要时直接拷贝离屏<code class="language-plaintext highlighter-rouge">Canvas</code>的图像即可。<code class="language-plaintext highlighter-rouge">Canvas</code> 绘制本身就是不断的更新帧从而达到动画的效果，通过使用离屏 <code class="language-plaintext highlighter-rouge">Canvas</code>，就大大减少了一些静态内容在上屏<code class="language-plaintext highlighter-rouge">Canvas</code>的绘制，从而提升了绘制性能。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td> --><td class="rouge-code"><pre><span class="k">this</span><span class="p">.</span><span class="nx">offScreenCanvas</span> <span class="o">=</span> <span class="nx">wx</span><span class="p">.</span><span class="nx">createCanvas</span><span class="p">()</span>
<span class="k">this</span><span class="p">.</span><span class="nx">offScreenCanvas</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">*</span> <span class="nx">ratio</span>
<span class="k">this</span><span class="p">.</span><span class="nx">offScreenCanvas</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">height</span> <span class="o">*</span> <span class="nx">ratio</span>

<span class="k">this</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">drawImage</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">offScreenCanvas</span><span class="p">,</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">ratio</span><span class="p">,</span> <span class="nx">y</span> <span class="o">*</span> <span class="nx">ratio</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">offScreenCanvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">offScreenCanvas</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="内存优化">内存优化</h3>

<p>玩家在游戏过程中拖动方块的移动其实就是不断更新多边形图形的坐标信息，然后不断的清空画布再重新绘制，可以想象，这个绘制是非常频繁的，按照普通的做法就需要不断去创建多个新的 <code class="language-plaintext highlighter-rouge">Block</code> 对象。针对游戏中需要频繁更新的对象，我们可以通过使用<code class="language-plaintext highlighter-rouge">对象池</code>的方法进行优化，对象池维护一个装着空闲对象的池子，如果需要对象的时候，不是直接<code class="language-plaintext highlighter-rouge">new</code>，而是从对象池中取出，如果对象池中没有空闲对象，则新建一个空闲对象，<strong>层叠拼图Plus</strong>小游戏内使用的是官方<code class="language-plaintext highlighter-rouge">demo</code>内已经实现的<code class="language-plaintext highlighter-rouge">对象池</code>类，实现如下：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td> --><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">__</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">poolDic</span><span class="p">:</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">poolDic</span><span class="dl">'</span><span class="p">)</span>
<span class="p">}</span>

<span class="cm">/**
 * 简易的对象池实现
 * 用于对象的存贮和重复使用
 * 可以有效减少对象创建开销和避免频繁的垃圾回收
 * 提高游戏性能
 */</span>
<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">Pool</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">[</span><span class="nx">__</span><span class="p">.</span><span class="nx">poolDic</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="p">}</span>

  <span class="cm">/**
   * 根据对象标识符
   * 获取对应的对象池
   */</span>
  <span class="nx">getPoolBySign</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">[</span><span class="nx">__</span><span class="p">.</span><span class="nx">poolDic</span><span class="p">][</span><span class="nx">name</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span> <span class="k">this</span><span class="p">[</span><span class="nx">__</span><span class="p">.</span><span class="nx">poolDic</span><span class="p">][</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">)</span>
  <span class="p">}</span>

  <span class="cm">/**
   * 根据传入的对象标识符，查询对象池
   * 对象池为空创建新的类，否则从对象池中取
   */</span>
  <span class="nx">getItemByClass</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">className</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">pool</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getPoolBySign</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>

    <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">(</span>  <span class="nx">pool</span><span class="p">.</span><span class="nx">length</span>
                  <span class="p">?</span> <span class="nx">pool</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span>
                  <span class="p">:</span> <span class="k">new</span> <span class="nx">className</span><span class="p">()</span>  <span class="p">)</span>

    <span class="k">return</span> <span class="nx">result</span>
  <span class="p">}</span>

  <span class="cm">/**
   * 将对象回收到对象池
   * 方便后续继续使用
   */</span>
  <span class="nx">recover</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">instance</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">getPoolBySign</span><span class="p">(</span><span class="nx">name</span><span class="p">).</span><span class="nx">push</span><span class="p">(</span><span class="nx">instance</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="垃圾回收">垃圾回收</h3>

<p>小游戏中，<code class="language-plaintext highlighter-rouge">JavaScript</code> 中的每一个 <code class="language-plaintext highlighter-rouge">Canvas</code> 或 <code class="language-plaintext highlighter-rouge">Image</code> 对象都会有一个客户端层的实际纹理储存，实际纹理储存中存放着 <code class="language-plaintext highlighter-rouge">Canvas</code>、<code class="language-plaintext highlighter-rouge">Image</code> 的真实纹理，通常会占用相当一部分内存。</p>

<p>每个客户端实际纹理储存的回收时机依赖于 <code class="language-plaintext highlighter-rouge">JavaScript</code> 中的 <code class="language-plaintext highlighter-rouge">Canvas</code>、<code class="language-plaintext highlighter-rouge">Image</code> 对象回收。在 <code class="language-plaintext highlighter-rouge">JavaScript</code> 的 <code class="language-plaintext highlighter-rouge">Canvas</code>、<code class="language-plaintext highlighter-rouge">Image</code> 对象被回收之前，客户端对应的实际纹理储存不会被回收。通过调用 <code class="language-plaintext highlighter-rouge">wx.triggerGC()</code> 方法，可以加快触发 <code class="language-plaintext highlighter-rouge">JavaScriptCore Garbage Collection</code>（垃圾回收），从而触发 <code class="language-plaintext highlighter-rouge">JavaScript</code> 中没有引用的 <code class="language-plaintext highlighter-rouge">Canvas</code>、<code class="language-plaintext highlighter-rouge">Image</code> 回收，释放对应的实际纹理储存。</p>

<p>但 <code class="language-plaintext highlighter-rouge">GC</code> 具体触发时机还要取决于 <code class="language-plaintext highlighter-rouge">JavaScriptCore</code> 自身机制，并不能保证调用 <code class="language-plaintext highlighter-rouge">wx.triggerGC()</code> 能马上触发回收，<strong>层叠拼图Plus</strong>小游戏在每局游戏开始或结束都会触发一下，及时回收内存垃圾，以保证最良好的游戏体验。</p>

<h3 id="多线程-worker">多线程 Worker</h3>

<p>对于游戏来说，每帧 <code class="language-plaintext highlighter-rouge">16ms</code> 是极其宝贵的，如果有一些可以异步处理的任务，可以放置于 <code class="language-plaintext highlighter-rouge">Worker</code> 中运行，待运行结束后，再把结果返回到主线程。<code class="language-plaintext highlighter-rouge">Worker</code> 运行于一个单独的全局上下文与线程中，不能直接调用主线程的方法，<code class="language-plaintext highlighter-rouge">Worker</code> 也不具备渲染的能力。 <code class="language-plaintext highlighter-rouge">Worker</code>与主线程之间的数据传输，双方使用 <code class="language-plaintext highlighter-rouge">Worker.postMessage()</code> 来发送数据，<code class="language-plaintext highlighter-rouge">Worker.onMessage()</code> 来接收数据，传输的数据并不是直接共享，而是被复制的。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td> --><td class="rouge-code"><pre><span class="c1">// game.json</span>
<span class="p">{</span>
  <span class="dl">"</span><span class="s2">workers</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">workers</span><span class="dl">"</span>
<span class="p">}</span>

<span class="c1">// 创建worker线程</span>
<span class="kd">let</span> <span class="nx">worker</span> <span class="o">=</span> <span class="nx">worker</span> <span class="o">=</span> <span class="nx">wx</span><span class="p">.</span><span class="nx">createWorker</span><span class="p">(</span><span class="dl">'</span><span class="s1">workers/request/index.js</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 文件名指定 worker 的入口文件路径，绝对路径</span>

<span class="c1">// 主线程向 Worker 发送消息</span>
<span class="nx">worker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">({</span>
  <span class="na">msg</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello worker</span><span class="dl">'</span>
<span class="p">})</span>

<span class="c1">// 主线程监听 Worker 返回消息</span>
<span class="nx">worker</span><span class="p">.</span><span class="nx">onMessage</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
<span class="p">})</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong><em>需要注意的是：<code class="language-plaintext highlighter-rouge">Worker</code> 最大并发数量限制为 <code class="language-plaintext highlighter-rouge">1</code> 个，创建下一个前请用 <code class="language-plaintext highlighter-rouge">Worker.terminate()</code> 结束当前 <code class="language-plaintext highlighter-rouge">Worker</code></em></strong></p>

<p>其他 <code class="language-plaintext highlighter-rouge">Worker</code> 相关的内容请参考微信官方文档：<a href="https://developers.weixin.qq.com/minigame/dev/guide/base-ability/worker.html">多线程 Worker</a></p>

<h2 id="结语">结语</h2>

<p>短短的一篇文章，定不能将<strong>层叠拼图Plus</strong>小游戏的前前后后讲明白讲透彻，加上文笔有限，有描述不当的地方还望多多海涵。其实最让人心累的还是软著的申请过程，由于各种原因前前后后花了将近三个月的时间，本来也想写一下软著申请相关的内容，最后发现篇幅有点长，无奈作罢，争取后面花点时间整理一下我这边的经验，希望可以帮助到需要的童鞋。</p>

<p>由于项目结构以及代码还比较混乱，个人觉得，目前暂时还不适合开源。<strong><em>好在，小游戏内的所有核心代码以及游戏实现思想均已呈上</em></strong>，有兴趣的同学如果有相关方面的疑问也可以与我多多交流，大家互相学习，共同进步。</p>

<p>体验游戏：</p>

<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca8b653f22285f?w=258&amp;h=258&amp;f=jpeg&amp;s=42561" alt="code" /></p>

<p>江湖不远，我们游戏里见！</p>
:ET